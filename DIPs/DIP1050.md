# Enable Implicit Function Template Instantiation for Constructors

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1050                                                            |
| Authors         | Jared Hanson, Dennis Korpel                                     |
| Review Count:   |                                                                 |
| Implementation: | [Dennis Korpel - PR 16910](https://github.com/dlang/dmd/pull/16910)|
| Status:         |                                                                 |

## Abstract

Implicit Function Template Instantiation (IFTI hereafter) and similar mechanisms have been
an unqualified success in both C++ and D, as well as other C-like languages such as Rust,
Java and C#, etc. Removing the need for programmers to explicitly specify types each time
a template function is called vastly improves the ergonomics of the D language as well as
the conciseness, readability, and "DRY factor" of code written in D.

One area where IFTI is _not_ currently done is when calling the constructor for a templated
type.

Ex:
```d
struct Pair(T, U)
{
    T t;
    U u;
   
    this(T t, U u)
    {
        this.t = t;
        this.u = u;
    }
}

Pair!(T, U) pair(T, U)(T t, U u)
{
    return Pair!(T, U)(t, u);
}

void main()
{
    auto p1 = pair(1, "asdf"); // Fine, T and U are inferred as "int" and "string"
    auto p2 = Pair(1, "asdf"); // Error: struct `Pair` is not callable using argument types `!()(int, string)`
                               //       Candidate is: `Pair(T, U)`
}
```

This DIP proposes that IFTI be enabled for constructors as well, just like for regular functions.

### Links

#### Github issue
- [Constructors of templated types should be callable via IFT](https://github.com/dlang/dmd/issues/18343)

#### From the Spec
- [Section 22.6.1 "Implicit Function Template Instantiation (IFTI)"](https://dlang.org/spec/template.html#ifti)

#### Forum Discussion
- [From September 30th 2025, "What was so crazy about IFTI for parent agregate via ctor call ?"](https://forum.dlang.org/post/dlaomdfxdzhxtpbsoixl@forum.dlang.org)

#### Prior Art from Other Languages
- [C++, "Class template argument deduction (CTAD)"](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
- [Rust, "Generic Data Types"](https://doc.rust-lang.org/book/ch10-01-syntax.html) (Note that implicit instantiation of both function and struct templates is demonstrated, but not explicitly discussed)
- [Rust, "Functions"](https://doc.rust-lang.org/rust-by-example/generics/gen_fn.html) (ditto)

## Description

The proposed changes to D are very simple, and are as follows:

1. Add `do` as an alternative keyword in place of `body`.
2. Temporarily make `body` a contextual keyword that is only a keyword when marking the body of a function. In all other conexts `body` may be used as a symbol name.
3. Schedule the `body` keyword for deprecation.
4. Once the deprecation period has ended, remove `body` as a keyword and only allow `do`.

These changes have a very simple migration path for user code while also allowing `body` to immediately be used as a symbol name. Making `body` a contextual keyword and deprecating it, while also allowing `do`, affords users plenty of time for code to be updated to use `do`. It also ensures that user code will not immediately be broken. Finally, it avoids any potential long-term problems with keeping body as a contextual keyword.

It is possible that using `do` to mark the function body may cause some confusion as to when `do` is referring to a function body or when it is referring to a loop body. However, the author does not believe that this is a concern; there are multiple keywords that risk causing similar confusion and yet, in practice, D users do not have trouble distinguishing which usage is intended within the surrounding context. One such example is the `if` template constraint syntax that looks identical to the regular `if`-statement syntax, save for the fact that it is only present after a template declaration.

The grammar will change as follows while either `body` or `do` are allowed:
```
# This
BodyStatement:
    body BlockStatement

# Becomes this
BodyStatement:
    body BlockStatement
    do BlockStatement
```

After `body` is deprecated and removed, the grammar will change as follows:
```
# This
BodyStatement:
    body BlockStatement
    do BlockStatement

# Becomes this
BodyStatement:
    do BlockStatement
```

Using the `do` keyword was suggested by [David Gileadi](http://forum.dlang.org/post/off8ag$3t5$1@digitalmars.com) and [Random D user](http://forum.dlang.org/post/rhuxwyotfctdfzxguatv@forum.dlang.org).

### Rationale

Many D programmers [complain](#forum-discussion) about `body` being a keyword in D. It is a commonly used word in many different fields and as such, a programmer working in these fields will regularly come into contact with the fact that it is a keyword (much to their annoyance).

Furthermore, D's contract programming features are rarely used compared to how
useful and desirable it is to be able to name a symbol "body". In the whole of
Phobos, there are fewer than 300 uses of the `body` keyword, which is very small compared to the library's total line count. However, even if D's contract
programming features _were_ heavily used, it would not compensate for the
inconvenience caused by `body` being a keyword. 

One of the reasons for this is
that there is only **one** context in which body is used, compared to the many
different contexts in user code in which the word "body" may be used as a symbol name. Therefore, this keyword does not "pull its weight" syntactically. This makes it very disruptive and annoying
when encountering such an issue in one's code.

A partial list of the contexts in which the word `body` might be used as a symbol name:

- In web programming where "body" is a required tag in any valid HTML document
- It is a name commonly used for XML tags and/or attributes
- Physics simulations as well in astronomical contexts ("planetary bodies", etc.)
- Video games, such as referring to the player character's body
- Working with HTTP requests and responses, which have a body
- Working programmatically with emails, which have a body
- Many external C and C++ libraries make use of "body" as a symbol name, making
  porting these to D and creating bindings for them more difficult
- Writing compilers and parsers (functions, loops, etc. all have bodies)
- Scripting interfaces and wrappers

Examples of game physics library code ported to D that use body as a symbol:

- [Example 1: dchip](https://github.com/d-gamedev-team/dchip/blob/55f43e5f0cf67c8bc190711b69eb16230fa6188e/src/dchip/cpBody.d#L184)
- [Example 2: dbox](https://github.com/d-gamedev-team/dbox/blob/6f81fe065abec1e7def44fc777c5d8e9da936104/examples/demo/tests/bodytypes.d#L103)
- [Example 3: chipmunkd](https://github.com/rcorre/chipmunkd/commit/d6bde5b649c70a53f4295f522e660fae3c1e740f)

### Breaking changes / deprecation process

As previously discussed, user code will not immediately broken, save for if the user compiles their code with the `-de` copmiler flag. There will be some breakage once the deprecation period ends and `body` is removed entirely; the intent is to allow a deprecation period that is long enough that most users will be able to update their code to use `do`. This process could be accelerated by encouraging users to employ [dfix](https://github.com/dlang-community/dfix) to update their code.

### Examples

#### How "body" might be used as a variable name in DOM-based code
```D
document.body.addEventListener("click"), (Event ev) { //Error, body is a keyword
    ev.target.appendText("got click!");
    ev.preventDefault();
});
```

#### How "body" Is Currently Used in Physics Simulation Code
```D
void cpBodyActivateStatic(cpBody* body_, cpShape* filter)
{
    cpAssertHard(cpBodyIsStatic(body_), "cpBodyActivateStatic() called on a non-static body_.");

    mixin(CP_BODY_FOREACH_ARBITER!("body_", "arb", q{
        if (!filter || filter == arb.a || filter == arb.b)
        {
            cpBodyActivate(arb.body_a == body_ ? arb.body_b : arb.body_a);
        }
    }));
}
```

#### Examples of How Code Will Change with This Proposal

```D
int div(int a, int b)
in { assert(b != 0); }
do
{
    return a / b;
}

auto div = function(int a, int b) in { assert(b != 0); } do { return a / b; };

long fact(int n)
in { assert(n >= 0); }
do
{
    long factHelper(int count, long acc)
    out(result) { assert(result >= acc); }
    do
    {
        if (count == 0)
            return acc;
        else
            return factHelper(count - 1, count * acc);
    }
    
    return factHelper(n, 1);
}
```

## Copyright & License

Copyright (c) 2025 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

### Reviews
