# Implicit Type Template Instantiation via Constructors

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1050                                                            |
| Authors         | Jared Hanson, Dennis Korpel                                     |
| Review Count:   |                                                                 |
| Implementation: | [Dennis Korpel - PR 16910](https://github.com/dlang/dmd/pull/16910)|
| Status:         |                                                                 |

## Abstract

Implicit Function Template Instantiation (IFTI hereafter) and similar mechanisms have been
an unqualified success in both C++ and D, as well as other C-like languages such as Rust,
Java and C#, etc. Removing the need for programmers to explicitly specify types each time
a template function is called vastly improves the ergonomics of the D language as well as
the conciseness, readability, and "DRY factor" of code written in D.

Ex:
```d
struct Pair(T, U)
{
    T t;
    U u;
}

Pair!(T, U) pair(T, U)(T t, U u)
{
    return Pair!(T, U)(t, u);
}

void main()
{
    auto p1 = pair(1, "asdf"); // Fine, T and U are inferred as "int" and "string"
}
```

This also works for templated constructors:
```d
struct Pair
{
    this(T, U)(T t, U u) {}
}

void main()
{
    auto p1 = Pair(1, "asdf"); // Fine, T and U are inferred as "int" and "string"
}
```

However, this is not particularly useful because the template arguments T and U are not accessible outside the scope of the constructor.
This can be solved by templating the entire aggregate. However, that introduces a new problem:
```d
struct Pair(T, U)
{
    T t;
    U u;

    this(T t, U u)
    {
        this.t = t;
        this.u = u;
    }
}

void main()
{
    auto p1 = Pair(1, "asdf"); // Error: struct `Pair` is not callable using argument types `!()(int, string)`
                               // Candidate is: `Pair(T, U)`
}
```

What is happening here? The problem is that IFTI can only "see" through 1 level of a template for the purposes of symbol lookup. Thus,
when it looks inside the `Pair(T, U)` template to lookup an entity that is callable with the given arguments, it only sees the struct
`Pair`, which as the error message specifies, is not callable.

**This proposal aims to change this behaviour so that IFTI can see through a 2nd level of uninstantiated templates, enabling it to
lookup constructors for a match when encountering a call to an uninstantiated template (like is done in the example above).**

Technically this new functionality is not IFTI (Implicit _Function_ Template Instantiation), but **ITTI** (Implicit _Type_ Template
Instantiation). IFTI and ITTI can then be grouped under the umbrella term **Implicit Template Instantiation** (ITI).

### Links

#### Github issue
- [Constructors of templated types should be callable via IFTI](https://github.com/dlang/dmd/issues/18343)

#### From the Spec
- [Section 22.6.1 "Implicit Function Template Instantiation (IFTI)"](https://dlang.org/spec/template.html#ifti)

#### Forum Discussion
- [From September 30th 2025, "What was so crazy about IFTI for parent agregate via ctor call ?"](https://forum.dlang.org/post/dlaomdfxdzhxtpbsoixl@forum.dlang.org)

#### Prior Art from Other Languages
- [C++, "Class template argument deduction (CTAD)"](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
- [Rust, "Generic Data Types"](https://doc.rust-lang.org/book/ch10-01-syntax.html) (Note that implicit instantiation of both function and struct templates is demonstrated, but not explicitly discussed)
- [Rust, "Functions"](https://doc.rust-lang.org/rust-by-example/generics/gen_fn.html) (ditto)
- [C#, "Generic methods"](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods)
- [Java, "Generic Methods"](https://docs.oracle.com/javase/tutorial/java/generics/methods.html)

## Description

Let's continue with the example from the abstract:
```d
struct Pair(T, U)
{
    T t;
    U u;

    this(T t, U u)
    {
        this.t = t;
        this.u = u;
    }
}

void main()
{
    auto p1 = Pair(1, "asdf"); // Error: struct `Pair` is not callable using argument types `!()(int, string)`
                               // Candidate is: `Pair(T, U)`
}
```

When the compiler encounters this code, it runs the current algorithm as follows:
1. An uninstantiated template is being called (the call to `Pair(1, "asdf")`) - that won't type check, so try IFTI.
2. Try [Eponymous Template Name Lookup](https://dlang.org/spec/template.html#implicit_template_properties) to get an entity from inside the template that is callable.
3. The only eponymous member of the template `Pair(T, U)` is the struct `Pair`, which is not callable (see the error message from the example).
4. Raise an error.

If the compiler were to examine the eponymous struct `S` for matching constructors, it would see that there is indeed a matching constructor (`this(T t, U u)`) that
_could_ be called with the given arguments.

That is what this proposal aims to do - to give IFTI the ability to looking through the 2nd level of an uninstantiated template to find matching constructors when
encountering a call to that template.

The algorith above will change to perform the following additional steps:
1. An uninstantiated template is being called (the call to `Pair(1, "asdf")`) - that won't type check, so try IFTI.
2. Try [Eponymous Template Name Lookup](https://dlang.org/spec/template.html#implicit_template_properties) to get an entity from inside the template that is callable.
3. The only eponymous member of the template `Pair(T, U)` is the struct `Pair`, which is not callable (see the error message from the example).
4. `Pair` is not callable using the given arguments, but it may have a constructor that is. Get a list of constructors from inside `Pair`.
5. If a matching constructor is found (in this case, `this(T t, U u)`, create a new constructor `this(T, U)(T t, U u)` and try IFTI with that.
6. IFTI will deduce `T = int` and `U = string` for this new constructor, and substituting those two types for its template arguments yields `Pair!(int, string)`.
7. Finally, the call `Pair(1, "asdf")` is rewritten to `Pair!(int, string)(1, "asdf")`.

Allowing the code from the example to compile.

## Rationale

ITTI is a feature that the D community has requested for years. In addition, there is a very tangible benefit that this feature will provide: no need for "trampoline" functions just to make use of ITI.

<Provide an example below using the trampoline function `std.typecons.tuple`>.

<Add stats on how many trampoline functions exist in Phobos?>

This change should essentially eliminate the need for such functions, reducing the number of template instantiations by the compiler, reducing object file
size, and ultimately reducing binary file size. The net result is faster compilation and smaller file sizes - 3 wins for the _very_ low price of 165 lines of D code (see attached PR).

## Cases that are _not_ part of this proposal

In the interest of keeping the changes to the language simple, here are some cases that are _not_ part of this proposal. This may change at a later date with subsequent DIPs.

### ITTI via static opCall

```d
struct Pair(T, U)
{
    T t;
    U u;
   
    static Pair!(T, U) opCall(T t, U u)
    {
        Pair!(T, U) p;
        p.t = t;
        p.u = u;
       
        return p;
    }
}

void main()
{
    auto p = Pair(1, "asdf"); // This will remain an error
}
```

### ITTI that can "see through" static-if, version, mixins, etc.

The current IFTI mechanism for looking up function signatures from outside an uninstantiated template is very simple; the following cases will "disable" it:
```d
template functionTemplate(T)
{
    void functionTemplate(T t) {} // Ok
    version(all) void functionTemplate(T t) {} // Nope
    static if (1) void functionTemplate(T t) {} // Nope
    mixin("void functionTemplate(T t) {}"); // Nope
}
```

This is rarely a problem, because very few D programmers write actual template definitions and instead opt for the shortened `void functionTemplate(T)(T t)` syntax.
However, it is much more common to selectively enable/disable, version in/out, or mixin a constructor inside of a template. Even with this proposal, ITI will fail
in these cases:
```d
struct Pair(T, U)
{
    T t;
    U u;

    static if (someCondition)
        this(T t, U u) { /* ... */ }

    version (someVersion)
        this(T t, U u) { /* ... */ }

    mixin(`this(T t, U u) { /* ... */ }`);
}

void main()
{
    auto p1 = Pair(1, "asdf"); // Error: struct `Pair` is not callable using argument types `!()(int, string)`
                               // Candidate is: `Pair(T, U)`
}
```

### Partial template parameter deduction

See https://dlang.org/spec/template.html#ifti.

The following case works for IFTI:
```d
void test(T, U)(T t, U u)
{
    import std;
    writeln("T = ", typeid(T), ", U = ", typeid(U));
}

void main()
{
    test!int(0, "asdf"); // Prints "T = int, U = immutable(char)[]"
}
```

However, even with this proposal, it will **NOT** work for ITTI:
```d
struct Pair(T, U)
{
    T t;
    U u;

    this(T t, U u) { /* ... */ }
}

void main()
{
    auto p = Pair!char('a', 'b'); // Error
}
```

#### Nested template constructors

This is not part of the current proposal, as it would significantly increase the complexity of the proposed new language feature.

```d
struct Pair(T, U)
{
    T t;
    U u;

    this(V)(T t, U u, V v) { /* ... */ }
}

void main()
{
    auto p = Pair(0, "asdf", false); // Error
}
```

## Breaking changes / deprecation process

As ITTI via constructors is currently not implemented in D, there are no breaking changes.

## Copyright & License

Copyright (c) 2025 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

### Reviews
