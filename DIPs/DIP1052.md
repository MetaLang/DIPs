# Tuple Unpacking Syntax

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1xxx                                                            |
| Review Count:   | 0                                                               |
| Author:         | Jared Hanson, Timon Gehr                                        |
| Implementation: | https://github.com/tgehr/dmd/tree/unpacking                     |
| Status:         | Will be set by the DIP manager (e.g. "Approved" or "Rejected")  |

## Abstract
This DIP proposes built-in language support for tuple unpacking.

## Links
- Walter's original post on tuple unpacking (2010):
  http://forum.dlang.org/post/i8jo6k$sba$1@digitalmars.com
  
  More posts on the topic can be found around October 07, 2010 (threading problems):
  http://forum.dlang.org/group/general?page=767

- DIP 32 (listing many alternative proposals): https://wiki.dlang.org/DIP32

- Some of the feature requests on the forums:
  - (2013) http://forum.dlang.org/post/gridjorxqlpoytuxwpsg@forum.dlang.org
  - (2017) https://forum.dlang.org/thread/glpsggkvxsiwxwfolwog@forum.dlang.org
    - Includes discussion with Steven Schveighoffer, which inspired proposal 2
  - (2017) http://forum.dlang.org/post/cktzfujipzzlloacthka@forum.dlang.org

- Killing the comma operator (2016): https://forum.dlang.org/thread/vcuinavnczqssdyewbjr@forum.dlang.org

## Rationale
The D programming language currently supports tuples with the library primitive `std.typecons.Tuple`, which has the following limitations:

- Tuples have to be unpacked manually:
  ```d
  Tuple!(int, string) foo();

  auto ab = foo(), a = ab[0], b = ab[1];

  int c;
  string d;
  c = ab[0];
  d = ab[1];
  ```

- Tuples have to be expanded manually:
  ```d
  auto a = [1, 2, 4, 7, 2];
  auto b = [3, 5, 3, 2, 4];
  
  int add(int a,int b)
  {
      return a + b;
  }
  auto c = zip(a, b).map!(t => add(t.expand));
  writeln(c); // "[4, 7, 7, 9, 6]\n"
  ```

- Existing tuple syntax is annoyingly verbose.


Treating multiple values as one tuple and unpacking a tuple back into multiple values is useful and should be supported with as little friction as possible. Built-in tuple syntax has previously been blocked by the comma operator, but using the result of a comma expression has now been deprecated, which enables progress on built-in tuple support.

Goals of this DIP:
- Allow manipulating tuples at least as conveniently as in other modern languages with built-in tuple support.
- Maintain backwards-compatibility with std.typecons.Tuple while keeping a clean semantics.
- Minimal language improvements leading to the desired effects.


## Description
This DIP includes six proposals that add more built-in tuple support to D, some of them are independent.

### Unpacking declarations
We add the following syntactic sugar to unpack a value sequence (including via `alias this`).
An unpack declaration declares (at least) one variable for each element of a sequence
expression.

- Variables are declared in a tuple pattern.
- A pattern is an optional storage class followed by parentheses containing 1 or more components.
    - Each pattern component is separated by a comma.
    - For a single component, a comma must precede the closing parenthesis.
- A component is either a nested pattern, or it consists of:
    - a storage class (may be optional)
    - a type (may be optional)
    - an identifier

Example:
```d
import std.typecons : tuple;

(int a, string b) = tuple(1, "2");
assert(a == 1);
assert(b == "2");
```

When there is a storage class for a pattern, each component of the pattern can
be just an identifier. Each variable type will be inferred from the corresponding
sequence element:

```d
auto (a, b) = tuple(1, "2");
```

The number of values has to match exactly. This restriction may be relaxed in a future DIP.

Patterns can be nested:
```d
auto (a, (b, c)) = tuple(1, tuple("2", 3.0));
(int a, (string b, double c)) = tuple(1, tuple("2", 3.0));
```

In a pattern where at least one component specifies a type, each component needs to specify a type or at least one storage class:
```d
(int a, b) = tuple(1, "2"); // error
(int a, auto b) = tuple(1, "2"); // ok

(int a, (b, c)) = tuple(1, tuple("2", 3.0)); // error
(int a, auto (b, c)) = tuple(1, tuple("2", 3.0)); // ok
(int a, (auto b, auto c)) = tuple(1, tuple("2", 3.0)); // ok

auto (a, immutable b, c) = tuple(1, "2", 3.0); // ok (restriction does not apply to storage classes)
```

Note: This rule leaves open the possibility of supporting unpacking tuple components into
a new variable declaration and [an existing lvalue expression](#postponed-unpacking-assignments)
within the same unpack declaration.

`static` or `enum` can be applied to the whole declaration, but not to individual components.


### Unpacking `foreach` elements
Similarly to unpacking variable declarations, `foreach` should also support unpack declarations.
For consistency with existing `foreach` variable declarations, the `auto` storage class is
implied unless overridden. The following 2 statements are equivalent:
```d
foreach((x, y); [tuple(1, "2"), tuple(3, "4"), tuple(5, "6")]) {
    writeln(x, " ", y); // "1 2\n3 4\n5 6"
}

foreach((int x, string y); [tuple(1, "2"), tuple(3, "4"), tuple(5, "6")]) {
    writeln(x, " ", y);// "1 2\n3 4\n5 6"
}
```
An index variable can be declared alongside
an unpacked element variable (when the *ForeachAggregate* supports it):
```d
import std.typecons : t = tuple;

// declare index for array & unpack tuple elements
foreach(i, (x, y); [t(1, 2), t(3, 4)]) {
    assert(x==2*i+1 && y==2*i+2);
}

import std.range;

auto arr = [t(1, 2), t(3, 4)];
foreach(i, (j, k); enumerate(arr)) {
    writeln(i," ",j," ",k); // "0 1 2\n1 3 4\n"
}
```
The index variable can also be unpacked:
```d
auto aa = [t(1, 2): "hi", t(3, 4): "bye"];
foreach ((a, b), s; aa)
    writeln(a, b, s); // "12hi\n34bye\n"
```
Normal `foreach` storage classes are supported, and they can apply to a tuple component
variable:
```d
auto arr = [t(1, 2), t(3, 4)];
foreach((ref x, y); arr) {
    x = 2*y;
}
assert(arr == [t(4, 2), t(8, 4)]);

foreach(const (x, y); arr) {
    static assert(is(typeof(x) == const(int)));
    static assert(is(typeof(y) == const(int)));
    assert(x == 2*y);
}
```
Unpacking can be used with `static foreach`:
```d
static foreach((a, b); [t(1,2), t(3,4)])
    pragma(msg, a, b); // "12\n34\n"
```
Unpacking can also be used with `opApply` and even when a range
[has an element type which is a value sequence](https://dlang.org/spec/statement.html#front-seq),
assuming one of the sequence components is itself a sequence. See [examples](#examples).


### Postponed: Unpacking assignments
Unpacking a tuple into lvalues is postponed until tuple literals are supported, because both
redefine the comma operator syntax.

```d
auto t = (1, 2); // tuple literal
int x, y;
(x, y) = t;
assert(x == 1);
assert(y == 2);
```
Using the result of a comma expression is already an error, which enables progress on
built-in tuple support. This will be done in a separate DIP.


### Unpacking function literal parameters
A function parameter must have a type, so function parameters cannot be unpacked without
tuple types, which are beyond the scope of this DIP. However, a function literal template
with an untyped unpack declaration parameter is supported:
```d
alias dg = ((x,y), z) => writeln(x," ",y," ",z);
dg(tuple(1, 2), 3); // "1 2 3\n"
```

`((x,y), z){ ... }` is lowered to `(__arg0, z){ auto (x,y) = __arg0; ...}`. In general, it preserves and copies storage classes from
the parameter to the unpack declaration in the function body.

`ref` storage class is copied outwards, e.g. if you do `((ref a,b), c){ ... }` that gets lowered to
`(ref __arg0, c){ (ref a,auto b) = __arg0; ... }`. 

`out` can be applied to the whole unpack parameter, but not to individual fields. `auto ref` and `lazy` cannot
be applied on an unpacking parameter list.

Note: `out` unpacking parameters are not supported by the current implementation, but may be added at a future date.


### Grammar changes
The following grammar additions will be sufficient.
(Note that many grammar rules are repeated due to (existing) distinct restrictions on what `StorageClasses` are allowed; this can make the proposed grammar changes look more profound than they are.)

#### Unpacking declarations
See <https://dlang.org/spec/declaration.html#VarDeclarations>.
```diff
  VarDeclarations:
      ...
      AutoDeclaration
+     StorageClasses[opt] TupleDeclarators ;

+ TupleDeclarators:
+     TupleDeclarator
+     TupleDeclarator , TupleDeclarators

+ TupleDeclarator:
+     ( TupleDeclarators2 ) = Initializer

+ TupleDeclarators2:
+     TupleDeclarator2 ,
+     TupleDeclarator2 , TupleDeclarator2
+     TupleDeclarator2 , TupleDeclarators2

+ TupleDeclarator2:
+     StorageClasses[opt] Identifier
+     StorageClasses[opt] BasicType TypeSuffixes[opt] Identifier
+     StorageClasses[opt] ( TupleDeclarators2 )
```

#### Unpacking `foreach` elements
(Note that `ForeachTupleDeclarators2` is the same as `TupleDeclarators2` except that the latter allows all `StorageClasses`, while the former allows only `ForeachTypeAttributes`.)

See <https://dlang.org/spec/statement.html#ForeachType>.
```diff
  ForeachType:
      ...
      ForeachTypeAttributes[opt] alias Identifier
+     ForeachTypeAttributes[opt] ( ForeachTupleDeclarators2 )

+ ForeachTupleDeclarators2:
+     ForeachTupleDeclarator2 ,
+     ForeachTupleDeclarator2 , ForeachTupleDeclarator2
+     ForeachTupleDeclarator2 , ForeachTupleDeclarators2

+ ForeachTupleDeclarator2:
+     ForeachTypeAttributes[opt] Identifier
+     ForeachTypeAttributes[opt] BasicType TypeSuffixes[opt] Identifier
+     ForeachTypeAttributes[opt] ( ForeachTupleDeclarators2 )
```

#### Proposal 5 (Unpacking function arguments)
(Note that `ParameterTupleDeclarator2` is the same as `TupleDeclarator2` except that the latter allows all `StorageClasses`, while the former allows only `ParameterAttributes`.)

See <https://dlang.org/spec/function.html#Parameter>.
```diff
Parameter:
      ...
      ParameterDeclaration = AssignExpression ...
+     ParameterAttributes[opt] ParameterTupleDeclarator

+ ParameterTupleDeclarator:
+     ( ParameterTupleDeclarators2 )
+     ( ParameterTupleDeclarators2 ) = Initializer

+ ParameterTupleDeclarators2:
+     ParameterTupleDeclarator2 ,
+     ParameterTupleDeclarator2 , ParameterTupleDeclarator2
+     ParameterTupleDeclarator2 , ParameterTupleDeclarators2

+ ParameterTupleDeclarator2:
+     ParameterAttributes[opt] Identifier
+     ParameterAttributes[opt] BasicType TypeSuffixes[opt] Identifier
+     ParameterAttributes[opt] ( ParameterTupleDeclarators2 )
```


### Breaking changes / deprecation process
This DIP introduces completely new syntax and semantics, and as such, it cannot break existing code.


### Examples
```d
import std.typecons:t=tuple,T=Tuple;
void main(){
     // unpack declarations
     auto (a, (b, c)) = t(1, t(2, "3"));
     assert(t(a, b, c) == t(1, 2, "3"));

     import std.stdio, std.string, std.conv;
     auto (u, v) = readln().strip.split.to!(T!(int,int));

     // works with opApply
     static struct Iota2d{
         int start,end;
         int opApply(scope int delegate(T!(int,int)) dg){
             foreach(i; start .. end) {
                 foreach(j; start ..end) {
                     if(auto r = dg(t(i,j)))
                         return r;
                 }
             }
             return 0;
         }
     }
     bool[4][4] visited;
     foreach((x, y); Iota2d(0,4)){
         visited[x][y] = true;
     }
     import std.algorithm;
     assert(visited[].all!((ref x)=>x[].all));

     // works with ranges of tuples
     struct TupleRange
     {
         size_t i = 1;
         auto front() => t(i, i + 1);
         bool empty() => i == 5;
         void popFront() { i += 2; }
     }
     import std.range;
     foreach (i, (a, b); enumerate(TupleRange()))
     {
         writeln(i, a, b); // "012\n134\n"
     }

     // can unpack in lambda parameter list
     [t(1,2),t(2,3)].map!( ((a, b)) => a+b ).each!writeln; // "3\n5\n"

     // works with storage classes
     auto arr = [t(1, 2), t(3, 4)];
     arr.each!( ((ref x, y)){ x = 3*y; });
     assert(arr.all!( (const (x, y)) => x == 3*y));
}
```

Example from DIP 32, originally by bearophile:
```d
import std.stdio, std.algorithm, std.container, std.array;

auto encode(T)(Group!("a == b", T[]) sf) {
    auto heap = sf.map!((c, f) => (f, [(c, "")])).array.heapify!q{b < a};

    while (heap.length > 1) {
        auto (lof, loa) = heap.front;  heap.removeFront;
        auto (hif, hia) = heap.front;  heap.removeFront;
        foreach ((_, ref e); loa) e = '0' ~ e;
        foreach ((_, ref e); hia) e = '1' ~ e;
        heap.insert((lof + hif, loa ~ hia));
    }
    return heap.front[1].schwartzSort!((c, e) => (e.length, c));
}

void main() {
    auto s = "this is an example for huffman encoding"d;
    foreach ((c, e); s.dup.sort().release.group.encode)
        writefln("'%s'  %s", c, e);
}
```


### Limitations

## Acknowledgements

## Copyright & License
Copyright (c) 2017 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)
