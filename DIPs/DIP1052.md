# Tuple Unpacking Syntax

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1xxx                                                            |
| Review Count:   | 0                                                               |
| Author:         | Jared Hanson, Timon Gehr                                        |
| Implementation: | https://github.com/tgehr/dmd/tree/unpacking                     |
| Status:         | Will be set by the DIP manager (e.g. "Approved" or "Rejected")  |

## Abstract
This DIP proposes built-in language support for tuple unpacking.

## Links
- Walter's original post on tuple unpacking (2010):
  http://forum.dlang.org/post/i8jo6k$sba$1@digitalmars.com
  
  More posts on the topic can be found around October 07, 2010 (threading problems):
  http://forum.dlang.org/group/general?page=767

- DIP 32 (listing many alternative proposals): https://wiki.dlang.org/DIP32

- Some of the feature requests on the forums:
  - (2013) http://forum.dlang.org/post/gridjorxqlpoytuxwpsg@forum.dlang.org
  - (2017) https://forum.dlang.org/thread/glpsggkvxsiwxwfolwog@forum.dlang.org
    - Includes discussion with Steven Schveighoffer, which inspired proposal 2
  - (2017) http://forum.dlang.org/post/cktzfujipzzlloacthka@forum.dlang.org

- Killing the comma operator (2016): https://forum.dlang.org/thread/vcuinavnczqssdyewbjr@forum.dlang.org

## Rationale
The D programming language currently supports tuples with the library primitive `std.typecons.Tuple`, which has the following limitations:

- Tuples have to be unpacked manually:
  ```d
  Tuple!(int, string) foo();

  auto ab = foo(), a = ab[0], b = ab[1];

  int c;
  string d;
  c = ab[0];
  d = ab[1];
  ```

- Tuples have to be expanded manually:
  ```d
  auto a = [1, 2, 4, 7, 2];
  auto b = [3, 5, 3, 2, 4];
  
  int add(int a,int b)
  {
      return a + b;
  }
  auto c = zip(a, b).map!(t => add(t.expand));
  writeln(c); // "[4, 7, 7, 9, 6]\n"
  ```

- Existing tuple syntax is annoyingly verbose.


Treating multiple values as one tuple and unpacking a tuple back into multiple values is useful and should be supported with as little friction as possible. Built-in tuple syntax has previously been blocked by the comma operator, but using the result of a comma expression has now been deprecated, which enables progress on built-in tuple support.

Goals of this DIP:
- Allow manipulating tuples at least as conveniently as in other modern languages with built-in tuple support.
- Maintain backwards-compatibility with std.typecons.Tuple while keeping a clean semantics.
- Minimal language improvements leading to the desired effects.


## Description
This DIP includes six proposals that add more built-in tuple support to D, some of them are independent.

### Unpacking declarations
We add the following syntactic sugar to unpack AliasSeq's (including via `alias this`).
```d
auto (a, b) = tuple(1, "2");
(int a, string b) = tuple(1, "2");
```

The number of values has to match exactly.

Patterns can be nested:
```d
auto (a, (b, c)) = tuple(1, tuple("2", 3.0));
(int a, (string b, double c)) = tuple(1, tuple("2", 3.0));
```

In a pattern where at least one component specifies a type, each component needs to specify a type or at least one storage class:
```d
(int a, b) = tuple(1, "2"); // error
(int a, auto b) = tuple(1, "2"); // ok

(int a, (b, c)) = tuple(1, tuple("2", 3.0)); // error
(int a, auto (b, c)) = tuple(1, tuple("2", 3.0)); // ok
(int a, (auto b, auto c)) = tuple(1, tuple("2", 3.0)); // ok

auto (a, immutable b, c) = tuple(1, "2", 3.0); // ok (restriction does not apply to storage classes)
```

`static`, and `enum` can be applied to the whole declaration, but not to individual components.


### Unpacking `foreach` elements
Similarly to unpacking variable declarations, `foreach` should also support unpack declarations.
For consistency with existing `foreach` variable declarations, the `auto` storage class is
implied unless overridden. The following 2 statements are equivalent:
```d
foreach((x, y); [tuple(1, "2"), tuple(3, "4"), tuple(5, "6")]) {
    writeln(x, " ", y); // "1 2\n3 4\n5 6"
}

foreach((int x, string y); [tuple(1, "2"), tuple(3, "4"), tuple(5, "6")]) {
    writeln(x, " ", y);// "1 2\n3 4\n5 6"
}
```
Only the element variable can be unpacked. An index variable can also be declared alongside
an unpacked element variable (when the *ForeachAggregate* supports it).
```d
import std.typecons : t = tuple;

// declare index for array & unpack tuple elements
foreach(i, (x, y); [t(1, 2), t(3, 4)]) {
    assert(x==2*i+1 && y==2*i+2);
}

import std.range;

auto arr = [t(1, 2), t(3, 4)];
foreach(i, (j, k); enumerate(arr)) {
    writeln(i," ",j," ",k); // "0 1 2\n1 3 4\n"
}
```
Normal `foreach` storage classes are supported:
```d
auto arr = [t(1, 2), t(3, 4)];
foreach((ref x, y); arr) {
    x = 2*y;
}
assert(arr == [t(4, 2), t(8, 4)]);

foreach(const (x, y); arr) {
    static assert(is(typeof(x) == const(int)));
    static assert(is(typeof(y) == const(int)));
    assert(x == 2*y);
}
```


### Unpacking assignments
A tuple of lvalues can be used as an lvalue in an assignment:

```d
(int, string) t = (1, "2");
int a;
string b;
(a, b) = t;

int x = 1, y = 2, z = 3;
(x, y) = (y, x);
assert((x, y) == (2, 1));

((x, y), z) = ((z, x), y); // nesting allowed
assert((x, y, z) == (3, 2, 1));

```

This should only be added if built-in tuple literals are added.


### Unpacking function arguments
```d
void foo((int x, int y), int z){
    writeln(x, " ", y, " ", z);
}

foo((1, 2), 3); // "1 2 3\n"

auto dg = ((x,y), z) => writeln(x," ",y," ",z);
dg((1, 2), 3); // "1 2 3\n"
```

`((x,y), z){ ... }` is lowered to `(__arg0, z){ auto (x,y) = __arg0; ...}`. In general, it preserves and copies storage classes from
the parameter to the unpack declaration in the function body.

`ref` storage class is copied outwards, e.g. if you do `((ref a,b), c){ ... }` that gets lowered to
`(ref __arg0, c){ (ref a,auto b) = __arg0; ... }`. 

`out` can be applied to the whole unpack parameter, but not to individual fields. `auto ref` and `lazy` cannot
be applied on an unpacking parameter list.

Note: `out` unpacking parameters are not supported by the current implementation, but may be added at a future date.


### Grammar changes
The following grammar additions will be sufficient.
(Note that many grammar rules are repeated due to (existing) distinct restrictions on what `StorageClasses` are allowed; this can make the proposed grammar changes look more profound than they are.)

#### Unpacking declarations
(Note that ForeachTupleDeclarators2 is the same as TupleDeclarators2 except that the former allows all `StorageClasses`, while the latter allows only `ForeachTypeAttributes`.)

```diff
  VarDeclarations:
      ...
      AutoDeclaration
+     StorageClasses[opt] TupleDeclarators ;

+ TupleDeclarators:
+     TupleDeclarator
+     TupleDeclarator , TupleDeclarators

+ TupleDeclarator:
+     ( TupleDeclarators2 )
+     ( TupleDeclarators2 ) = Initializer

+ TupleDeclarators2:
+     TupleDeclarator2 ,
+     TupleDeclarator2 , TupleDeclarator2
+     TupleDeclarator2 , TupleDeclarators2

+ TupleDeclarator2:
+     StorageClasses[opt] Identifier
+     StorageClasses[opt] BasicType BasicType2[opt] Identifier
+     StorageClasses[opt] ( TupleDeclarators2 )
```

#### Unpacking `foreach` elements
```diff
  ForeachType:
      ...
      ForeachTypeAttributes[opt] alias Identifier
+     ForeachTypeAttributes[opt] ( ForeachTupleDeclarators2 )

+ ForeachTupleDeclarators2:
+     ForeachTupleDeclarator2 ,
+     ForeachTupleDeclarator2 , ForeachTupleDeclarator2
+     ForeachTupleDeclarator2 , ForeachTupleDeclarators2

+ ForeachTupleDeclarator2:
+     ForeachTypeAttributes[opt] Identifier
+     ForeachTypeAttributes[opt] BasicType BasicType2[opt] Identifier
+     ForeachTypeAttributes[opt] ( ForeachTupleDeclarators2 )
```

#### Unpacking assignments
The grammar additions for tuple literals suffice. For an unpacking assignment, the tuple literal is interpreted as an lvalue during semantic.

#### Proposal 5 (Unpacking function arguments)
(Note that ParameterTupleDeclarator is the same as TupleDeclarator except that the former allows all `StorageClasses`, while the latter allows only `InOut`.)
```diff
+ ParameterTupleDeclarator:
+     ( ParameterTupleDeclarators2 )
+     ( ParameterTupleDeclarators2 ) = Initializer

+ ParameterTupleDeclarators2:
+     ParameterTupleDeclarator2 ,
+     ParameterTupleDeclarator2 , ParameterTupleDeclarator2
+     ParameterTupleDeclarator2 , ParameterTupleDeclarators2

+ ParameterTupleDeclarator2:
+     InOut[opt] Identifier
+     InOut[opt] BasicType BasicType2[opt] Identifier
+     InOut[opt] ( ParameterTupleDeclarators2 )

  Parameter:
      ...
      InOut[opt] Type ...
+     InOut[opt] ParameterTupleDeclarator

TODO: FUNCTION LITERALS
```


### Breaking changes / deprecation process
This DIP introduces completely new syntax and semantics, and as such, it cannot break existing code.


### Examples
```d
import std.typecons:t=tuple,T=Tuple;
void main(){
     // unpack declarations
     auto (a, (b, c)) = t(1, t(2, "3"));
     assert(t(a, b, c) == t(1, 2, "3"));

     import std.stdio, std.string, std.conv;
     auto (u, v) = readln().strip.split.to!(T!(int,int));

     // works with opApply
     static struct Iota2d{
         int start,end;
         int opApply(scope int delegate(T!(int,int)) dg){
             foreach(i; start .. end) {
                 foreach(j; start ..end) {
                     if(auto r = dg(t(i,j)))
                         return r;
                 }
             }
             return 0;
         }
     }
     bool[4][4] visited;
     foreach((x, y); Iota2d(0,4)){
         visited[x][y] = true;
     }
     import std.algorithm;
     assert(visited[].all!((ref x)=>x[].all));

     // can unpack in lambda parameter list
     [t(1,2),t(2,3)].map!( ((a, b)) => a+b ).each!writeln; // "3\n5\n"

     // works with storage classes
     auto arr = [t(1, 2), t(3, 4)];
     arr.each!( ((ref x, y)){ x = 3*y; });
     assert(arr.all!( (const (x, y)) => x == 3*y));
}
```

Example from DIP 32, originally by bearophile:
```d
import std.stdio, std.algorithm, std.container, std.array;

auto encode(T)(Group!("a == b", T[]) sf) {
    auto heap = sf.map!((c, f) => (f, [(c, "")])).array.heapify!q{b < a};

    while (heap.length > 1) {
        auto (lof, loa) = heap.front;  heap.removeFront;
        auto (hif, hia) = heap.front;  heap.removeFront;
        foreach ((_, ref e); loa) e = '0' ~ e;
        foreach ((_, ref e); hia) e = '1' ~ e;
        heap.insert((lof + hif, loa ~ hia));
    }
    return heap.front[1].schwartzSort!((c, e) => (e.length, c));
}

void main() {
    auto s = "this is an example for huffman encoding"d;
    foreach ((c, e); s.dup.sort().release.group.encode)
        writefln("'%s'  %s", c, e);
}
```


### Limitations
Currently, slices of `std.typecons.Tuple`s auto-expand. Ideally, slicing a tuple would produce another tuple (instead of an AliasSeq).
As this DIP is based on rewriting to the current implementation of `std.typecons.Tuple`, this situation is unfortunately not addressed:

```d
void foo((int, double) t){}

foo((1, 2.0, "3")[0..2]); // error

foo(((1, 2.0, "3")[0..2],)); // ok
```

This illustrates another limitation: it is still not possible to call a function that takes a single tuple with multiple arguments.

## Acknowledgements

## Copyright & License
Copyright (c) 2017 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)
